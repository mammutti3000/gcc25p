<!DOCTYPE html>
<html lang="fi">
<head>
  <meta charset="UTF-8" />
  <title>Turku Pollution Of Routes</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    body, html { margin: 0; padding: 0; height: 100%; font-family: sans-serif; }
    #map { width: 100%; height: 90vh; }
    #controls {
      padding: 10px;
      background: #f8f8f8;
      border-bottom: 1px solid #ccc;
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }
    button {
      padding: 6px 12px;
      font-size: 14px;
      cursor: pointer;
    }
    #route-info {
      font-weight: bold;
    }
  </style>
  <script src="https://unpkg.com/georaster"></script>
  <script src="https://unpkg.com/georaster-layer-for-leaflet"></script>
  
</head>
<body>

  <div id="controls">
    <button onclick="setMode('start')">Select startpoint</button>
    <button onclick="setMode('end')">Select endpoint</button>
    <button onclick="calculateRoute()">Calculate route</button>
    <button onclick="resetRoute()">Reset</button>
    <button onclick="togglePoints()">School layer on/off</button>
    <button onclick="toggleRaster()">pollution layer on/off</button>
    <div id="route-info">No route to calculate</div>
  </div>

  <div id="map"></div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <script>
    const map = L.map("map").setView([60.4518, 22.2666], 13);
    L.tileLayer("https://{s}.tile.openstreetmap.fr/hot/{z}/{x}/{y}.png", {
      attribution: '&copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a>',
    }).addTo(map);

    let currentMode = null;
    let startPoint = null;
    let endPoint = null;
    let startMarker = null;
    let endMarker = null;
    let routeLine = [];
    let geojsonFeatures = [];

    let pointLayer = L.layerGroup().addTo(map); // koulut
    let rasterLayer = L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png'); // rasteri


    function setMode(mode) {
      currentMode = mode;
    }

    map.on("click", function (e) {
      if (currentMode === 'start') {
        if (startMarker) map.removeLayer(startMarker);
        startPoint = e.latlng;
        startMarker = L.marker(startPoint).addTo(map).bindPopup("Start").openPopup();
      } else if (currentMode === 'end') {
        if (endMarker) map.removeLayer(endMarker);
        endPoint = e.latlng;
        endMarker = L.marker(endPoint).addTo(map).bindPopup("Goal").openPopup();
      }
    });

    function calculateRoute() {
      if (!startPoint || !endPoint) {
        alert("Please select startpoint and endpoint first");
        return;
      }

      const url = `https://router.project-osrm.org/route/v1/walking/${startPoint.lng},${startPoint.lat};${endPoint.lng},${endPoint.lat}?overview=full&geometries=geojson&alternatives=true`;

      fetch(url)
        .then(response => response.json())
        .then(data => {
            // poistetaan vanhat reitit
            if (routeLine.length) {
                routeLine.forEach(line => map.removeLayer(line));
                routeLine = []; // Tyhjennetään vanhat reitit
                geojsonFeatures = [];
            }
          
            const infoTexts = [];
            

            // nopein reitti
            const route1 = data.routes[0];
            const coords1 = route1.geometry.coordinates.map(c => [c[1], c[0]]);
            const polyline1 = L.polyline(coords1, { color: "blue", weight: 4, dashArray: '5, 5' }).addTo(map);
            routeLine.push(polyline1)

            // Toinen reitti (jos löytyy): "vihreämpi"
            if (data.routes.length > 1) {
              const route2 = data.routes[1];
              const coords2 = route2.geometry.coordinates.map(c => [c[1], c[0]]);
              const polyline2 = L.polyline(coords2, { color: "green", weight: 4, dashArray: '5, 5' }).addTo(map);
              routeLine.push(polyline2);
          }



            map.fitBounds(routeLine[0].getBounds());

            const distanceMeters = data.routes[0].distance;
            const distanceKm = (distanceMeters / 1000).toFixed(2);
            const emissionsKg = 0; // Tulevaisuudessa lasketaan

            const altDistanceMeters = data.routes.length > 1 ? data.routes[1].distance : 0;
            const altDistanceKm = (altDistanceMeters / 1000).toFixed(2);
            const altEmissions = 0; // Alustava

            document.getElementById("route-info").innerHTML = `
              <div><strong>Normal Route (blue)</strong>: ${distanceKm} km | Pollution: ${emissionsKg}</div>
              <div><strong>Better Choice (green)</strong>: ${altDistanceKm} km | Pollution: ${altEmissions}</div>
            `;

          });
      }

    // nollaillaan settejä.
    function resetRoute() {
      if (startMarker) map.removeLayer(startMarker);
      if (endMarker) map.removeLayer(endMarker);
      startMarker = endMarker = null;
      startPoint = endPoint = null;
      routeLine.forEach(r => map.removeLayer(r));
      routeLine = [];
      geojsonFeatures = [];
      document.getElementById("route-info").innerText = "No route to calculate";
      }
      
    function downloadGeoJSON() {
      if (geojsonFeatures.length === 0) {
        alert("Ei reittejä tallennettavaksi!");
        return;
      }
      const geojson = {
        type: "FeatureCollection",
        features: geojsonFeatures
      };

      const blob = new Blob([JSON.stringify(geojson, null, 2)], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.href = url;
      link.download = "reitit.geojson";
      link.click();
      URL.revokeObjectURL(url);
    }


    function togglePoints() {
      if (map.hasLayer(pointLayer)) {
        map.removeLayer(pointLayer);
      } else {
        map.addLayer(pointLayer);
      }
    }

    
    let pollutionLayer = null;
    let pollutionVisible = false;

    function toggleRaster() {
      if (pollutionVisible) {
        if (pollutionLayer) map.removeLayer(pollutionLayer);
        pollutionVisible = false;
      } else {
        if (pollutionLayer) {
          map.addLayer(pollutionLayer);
        } else {
          // Ladataan vain kerran
          fetch("data/PM2_5_2024_spring_g.tiff") // geotiffi
            .then(response => response.arrayBuffer())
            .then(arrayBuffer => {
              parseGeoraster(arrayBuffer).then(georaster => {
                pollutionLayer = new GeoRasterLayer({
                  georaster: georaster,
                  opacity: 0.6,
                  pixelValuesToColorFn: values => {
                    const val = values[0];
                    if (val === 0) return null;
                    return `rgba(0, ${Math.min(255, val * 10)}, 0, 0.6)`; // vihreä
                  }
                }).addTo(map);
                map.fitBounds(pollutionLayer.getBounds());
              });
            });
        }
        pollutionVisible = true;
      }
    }

</script>
</body>
</html>
